"use strict";
(self["webpackChunk_crownfi_css_gothic_fantasy"] = self["webpackChunk_crownfi_css_gothic_fantasy"] || []).push([["node_modules_aritz-cracker_browser-utils_dist_workarounds_range-input-fill_js"],{

/***/ "./node_modules/@aritz-cracker/browser-utils/dist/workarounds/range-input-fill.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@aritz-cracker/browser-utils/dist/workarounds/range-input-fill.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
// Get the original getters/setters for the input element
const originalInputDescriptor = Object.getOwnPropertyDescriptor(HTMLInputElement.prototype, "valueAsNumber");
function updateCSSVariable(elem, curVal = elem.valueAsNumber) {
    if (elem.type !== "range") {
        return;
    }
    // The default min/max values replicates built-in behaviour
    const minVal = (elem.min === "" || isNaN(elem.min)) ? 0 : Number(elem.min);
    const maxVal = (elem.max === "" || isNaN(elem.max)) ? 100 : Number(elem.max);
    elem.style.setProperty('--range-workaround-fill-amount', ((curVal - minVal) / (maxVal - minVal)) + "");
}
// Unique symbol to check if we already patched
const rangeProgressWorkaroundApplied = Symbol("rangeProgressWorkaroundApplied");
// Patches the element so that changes to .value and .valueAsNumber calls updateCSSVariable 
function patchRangeInput(elem) {
    if (elem[rangeProgressWorkaroundApplied]) {
        if (elem.type != "range") {
            // This element isn't a range input anymore, remove our setters.
            delete elem.value;
            delete elem.valueAsNumber;
            // This element may turn back into a range input in the future...
            delete elem[rangeProgressWorkaroundApplied];
        }
        return;
    }
    if (elem.type != "range") {
        return;
    }
    function setterValueCallback(val) {
        val = Number(val);
        if (isNaN(val)) {
            // The default min/max values replicates built-in behaviour
            const minVal = (elem.min === "" || isNaN(elem.min)) ? 0 : Number(elem.min);
            const maxVal = (elem.max === "" || isNaN(elem.max)) ? 100 : Number(elem.max);
            // Setting the value to 50% on an invalid value replicates built-in behaviour
            val = Math.round((minVal + maxVal) / 2);
        }
        updateCSSVariable(elem, val);
        originalInputDescriptor.set.call(elem, val);
    }
    Object.defineProperty(elem, "value", {
        set: setterValueCallback,
        get: () => {
            return String(originalInputDescriptor.get.call(elem));
        }
    });
    Object.defineProperty(elem, "valueAsNumber", {
        set: setterValueCallback,
        get: () => {
            return originalInputDescriptor.get.call(elem);
        }
    });
    elem[rangeProgressWorkaroundApplied] = true;
    updateCSSVariable(elem);
}
function updateCSSVariableOnTarget(ev) {
    updateCSSVariable(ev.target);
}
document.addEventListener("input", updateCSSVariableOnTarget, { passive: true });
document.addEventListener("change", updateCSSVariableOnTarget, { passive: true });
const newRangeInputObserver = new MutationObserver((records) => {
    for (const record of records) {
        for (const addedNode of record.addedNodes) {
            if (addedNode instanceof HTMLInputElement) {
                patchRangeInput(addedNode);
            }
        }
        if (record.target instanceof HTMLInputElement) {
            patchRangeInput(record.target);
        }
    }
});
function onDocumentLoaded() {
    document.querySelectorAll("input[type=\"range\"]").forEach(elem => {
        patchRangeInput(elem);
    });
    newRangeInputObserver.observe(document.body, { childList: true, subtree: true, attributeFilter: ["type"] });
}
if (document.readyState == "loading") {
    document.addEventListener("DOMContentLoaded", onDocumentLoaded);
}
else {
    onDocumentLoaded();
}



/***/ })

}]);